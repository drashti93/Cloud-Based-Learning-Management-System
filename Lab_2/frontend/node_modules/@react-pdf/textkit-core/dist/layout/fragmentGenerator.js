'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _Rect = require('../geom/Rect');

var _Rect2 = _interopRequireDefault(_Rect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LEFT = 0;
var RIGHT = 1;
var BELOW = 1;
var INSIDE = 2;
var ABOVE = 3;
var INTERIOR = 1;
var EXTERIOR = 2;

var BELOW_TO_INSIDE = BELOW << 4 | INSIDE;
var BELOW_TO_ABOVE = BELOW << 4 | ABOVE;
var INSIDE_TO_BELOW = INSIDE << 4 | BELOW;
var INSIDE_TO_ABOVE = INSIDE << 4 | ABOVE;
var ABOVE_TO_INSIDE = ABOVE << 4 | INSIDE;
var ABOVE_TO_BELOW = ABOVE << 4 | BELOW;

var xIntersection = function xIntersection(e, t, n) {
  var r = e - n.y;
  var i = t.y - n.y;
  return r / i * (t.x - n.x) + n.x;
};

var splitLineRect = function splitLineRect(lineRect, polygon, type) {
  var minY = lineRect.y;
  var maxY = lineRect.maxY;
  var markers = [];
  var wrapState = BELOW;
  var min = Infinity;
  var max = -Infinity;

  for (var i = 0; i < polygon.contours.length; i++) {
    var contour = polygon.contours[i];
    var index = -1;
    var state = -1;

    // Find the first point outside the line rect.
    do {
      var point = contour[++index];
      state = point.y <= minY ? BELOW : point.y >= maxY ? ABOVE : INSIDE;
    } while (state === INSIDE && index < contour.length - 1);

    // Contour is entirely inside the line rect. Skip it.
    if (state === INSIDE) {
      continue;
    }

    var dir = type === EXTERIOR ? 1 : -1;
    var idx = type === EXTERIOR ? index : contour.length + index;
    var currentPoint = void 0;

    for (var _index = 0; _index <= contour.length; _index++, idx += dir) {
      var _point = contour[idx % contour.length];

      if (_index === 0) {
        currentPoint = _point;
        state = _point.y <= minY ? BELOW : _point.y >= maxY ? ABOVE : INSIDE;
        continue;
      }

      var s = _point.y <= minY ? BELOW : _point.y >= maxY ? ABOVE : INSIDE;
      var x = _point.x;

      if (s !== state) {
        var stateChangeType = state << 4 | s;
        switch (stateChangeType) {
          case BELOW_TO_INSIDE:
            {
              // console.log('BELOW_TO_INSIDE')
              var xIntercept = xIntersection(minY, _point, currentPoint);
              min = Math.min(xIntercept, x);
              max = Math.max(xIntercept, x);
              wrapState = BELOW;
              break;
            }

          case BELOW_TO_ABOVE:
            {
              // console.log('BELOW_TO_ABOVE')
              var x1 = xIntersection(minY, _point, currentPoint);
              var x2 = xIntersection(maxY, _point, currentPoint);
              markers.push({
                type: LEFT,
                position: Math.max(x1, x2)
              });
              break;
            }

          case ABOVE_TO_INSIDE:
            {
              // console.log('ABOVE_TO_INSIDE')
              var _xIntercept = xIntersection(maxY, _point, currentPoint);
              min = Math.min(_xIntercept, x);
              max = Math.max(_xIntercept, x);
              wrapState = ABOVE;
              break;
            }

          case ABOVE_TO_BELOW:
            {
              // console.log('ABOVE_TO_BELOW')
              var _x = xIntersection(minY, _point, currentPoint);
              var _x2 = xIntersection(maxY, _point, currentPoint);
              markers.push({
                type: RIGHT,
                position: Math.min(_x, _x2)
              });
              break;
            }

          case INSIDE_TO_ABOVE:
            {
              // console.log('INSIDE_TO_ABOVE')
              var _x3 = xIntersection(maxY, _point, currentPoint);
              max = Math.max(max, _x3);

              markers.push({ type: LEFT, position: max });

              if (wrapState === ABOVE) {
                min = Math.min(min, _x3);
                markers.push({ type: RIGHT, position: min });
              }

              break;
            }

          case INSIDE_TO_BELOW:
            {
              // console.log('INSIDE_TO_BELOW')
              var _x4 = xIntersection(minY, _point, currentPoint);
              min = Math.min(min, _x4);

              markers.push({ type: RIGHT, position: min });

              if (wrapState === BELOW) {
                max = Math.max(max, _x4);
                markers.push({ type: LEFT, position: max });
              }

              break;
            }

          default:
            throw new Error('Unknown state change');
        }
        state = s;
      } else if (s === INSIDE) {
        min = Math.min(min, x);
        max = Math.max(max, x);
      }

      currentPoint = _point;
    }
  }

  markers.sort(function (a, b) {
    return a.position - b.position;
  });

  var G = 0;
  if (type === '' || markers.length > 0 && markers[0].type === LEFT) {
    G++;
  }

  var minX = lineRect.x;
  var maxX = lineRect.maxX;
  var height = lineRect.height;

  var rects = [];

  for (var _iterator = markers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var marker = _ref;

    if (marker.type === RIGHT) {
      if (G === 0) {
        var p = Math.min(maxX, marker.position);
        if (p >= minX) {
          rects.push(new _Rect2.default(minX, minY, p - minX, height));
        }
      }

      G++;
    } else {
      G--;
      if (G === 0 && marker.position > minX) {
        minX = marker.position;
      }
    }
  }

  if (G === 0 && maxX >= minX) {
    rects.push(new _Rect2.default(minX, minY, maxX - minX, height));
  }

  return rects;
};

/**
 * A LineFragmentGenerator splits line rectangles into fragments,
 * wrapping inside a container's polygon, and outside its exclusion polygon.
 */
var generateLineFragments = function generateLineFragments(lineRect, container) {
  var exclusion = container.exclusionPolygon;
  var rects = splitLineRect(lineRect, container.polygon, INTERIOR);

  if (exclusion) {
    var res = [];
    for (var _iterator2 = rects, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var rect = _ref2;

      res.push.apply(res, splitLineRect(rect, exclusion, EXTERIOR));
    }

    return res;
  }

  return rects;
};

var generateFragments = function generateFragments(paragraphRect, lineHeight, container) {
  var lineFragements = [];
  var yCount = paragraphRect.y;

  while (paragraphRect.height + paragraphRect.y >= yCount + lineHeight) {
    var lineRect = new _Rect2.default(paragraphRect.x, yCount, paragraphRect.width, lineHeight);
    lineFragements.push.apply(lineFragements, generateLineFragments(lineRect, container));
    yCount += lineHeight;
  }

  return lineFragements;
};

exports.default = generateFragments;