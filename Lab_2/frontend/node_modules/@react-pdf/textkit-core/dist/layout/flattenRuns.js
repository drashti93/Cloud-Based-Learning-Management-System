'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _Run = require('../models/Run');

var _Run2 = _interopRequireDefault(_Run);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var flattenRuns = function flattenRuns() {
  var runs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var regularRuns = runs.filter(function (run) {
    return run.start !== run.end;
  });
  var emptyRuns = runs.filter(function (run) {
    return run.start === run.end;
  });

  var regularFlattenRuns = flattenRegularRuns(regularRuns);
  var emptyFlattenRuns = flattenEmptyRuns(emptyRuns);
  var sortRuns = function sortRuns(a, b) {
    return a.start - b.start || a.end - b.end;
  };

  return [].concat(regularFlattenRuns, emptyFlattenRuns).sort(sortRuns);
};

var flattenEmptyRuns = function flattenEmptyRuns(runs) {
  var points = runs.reduce(function (acc, run) {
    if (!acc.includes(run.start)) {
      return [].concat(acc, [run.start]);
    }

    return acc;
  }, []);

  return points.map(function (point) {
    var pointRuns = runs.filter(function (run) {
      return run.start === point;
    });
    var attrs = pointRuns.reduce(function (acc, run) {
      return (0, _assign2.default)({}, acc, run.attributes);
    }, {});

    return new _Run2.default(point, point, attrs);
  });
};

var flattenRegularRuns = function flattenRegularRuns(runs) {
  var res = [];
  var points = [];

  for (var i = 0; i < runs.length; i++) {
    var run = runs[i];
    points.push(['start', run.start, run.attributes, i]);
    points.push(['end', run.end, run.attributes, i]);
  }

  points.sort(function (a, b) {
    return a[1] - b[1] || a[3] - b[3];
  });

  var start = -1;
  var attrs = {};
  var stack = [];

  for (var _iterator = points, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref2;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref2 = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref2 = _i.value;
    }

    var _ref = _ref2;
    var type = _ref[0];
    var offset = _ref[1];
    var attributes = _ref[2];

    if (start !== -1 && start < offset) {
      res.push(new _Run2.default(start, offset, attrs));
    }

    if (type === 'start') {
      stack.push(attributes);
      attrs = (0, _assign2.default)({}, attrs, attributes);
    } else {
      attrs = {};

      for (var _i2 = 0; _i2 < stack.length; _i2++) {
        if (stack[_i2] === attributes) {
          stack.splice(_i2--, 1);
        } else {
          (0, _assign2.default)(attrs, stack[_i2]);
        }
      }
    }

    start = offset;
  }

  return res;
};

exports.default = flattenRuns;