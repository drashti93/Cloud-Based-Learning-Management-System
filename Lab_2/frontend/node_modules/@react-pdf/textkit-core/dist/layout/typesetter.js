'use strict';

exports.__esModule = true;

var _fragmentGenerator = require('./fragmentGenerator');

var _fragmentGenerator2 = _interopRequireDefault(_fragmentGenerator);

var _Block = require('../models/Block');

var _Block2 = _interopRequireDefault(_Block);

var _LineFragment = require('../models/LineFragment');

var _LineFragment2 = _interopRequireDefault(_LineFragment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NEW_LINE = 10;
var ALIGNMENT_FACTORS = {
  left: 0,
  center: 0.5,
  right: 1,
  justify: 0
};

var finalizeLineFragment = function finalizeLineFragment(engines) {
  return function (line, style, isLastFragment, isTruncated) {
    var align = isLastFragment && !isTruncated ? style.alignLastLine : style.align;

    if (isLastFragment && isTruncated && style.truncationMode) {
      engines.truncationEngine.truncate(line, style.truncationMode);
    }

    var start = 0;
    var end = line.length;

    // Remove new line char at the end of line
    if (line.codePointAtGlyphIndex(line.length - 1) === NEW_LINE) {
      line.deleteGlyph(line.length - 1);
    }

    // Ignore whitespace at the start and end of a line for alignment
    while (line.isWhiteSpace(start)) {
      line.overflowLeft += line.getGlyphWidth(start++);
    }

    while (line.isWhiteSpace(end - 1)) {
      line.overflowRight += line.getGlyphWidth(--end);
    }

    // Adjust line rect for hanging punctuation
    if (style.hangingPunctuation) {
      if (align === 'left' || align === 'justify') {
        if (line.isHangingPunctuationStart(start)) {
          line.overflowLeft += line.getGlyphWidth(start++);
        }
      }

      if (align === 'right' || align === 'justify') {
        if (line.isHangingPunctuationEnd(end - 1)) {
          line.overflowRight += line.getGlyphWidth(--end);
        }
      }
    }

    line.rect.x -= line.overflowLeft;
    line.rect.width += line.overflowLeft + line.overflowRight;

    // Adjust line offset for alignment
    var remainingWidth = line.rect.width - line.advanceWidth;
    line.rect.x += remainingWidth * ALIGNMENT_FACTORS[align];

    if (align === 'justify' || line.advanceWidth > line.rect.width) {
      engines.justificationEngine.justify(line, {
        factor: style.justificationFactor
      });
    }

    engines.decorationEngine.createDecorationLines(line);
  };
};

var layoutParagraph = function layoutParagraph(engines) {
  return function (paragraph, container, lineRect) {
    var value = paragraph.value,
        syllables = paragraph.syllables;

    var style = value.glyphRuns[0].attributes;

    // Guess the line height using the full line before intersecting with the container.
    // Generate line fragment rectangles by intersecting with the container.
    var lineHeight = value.slice(0, value.glyphIndexAtOffset(lineRect.width)).height;
    var fragmentRects = (0, _fragmentGenerator2.default)(lineRect, lineHeight, container);
    var wrappingWidths = fragmentRects.map(function (rect) {
      return rect.width;
    });
    var lines = engines.lineBreaker.suggestLineBreak(value, syllables, wrappingWidths, style);

    var currentY = lineRect.y;
    var lineFragments = lines.map(function (line, i) {
      var lineBox = fragmentRects[Math.min(i, fragmentRects.length - 1)].copy();
      var fragmentHeight = Math.max(line.height, style.lineHeight);

      lineBox.y = currentY;
      lineBox.height = fragmentHeight;
      currentY += fragmentHeight;

      return new _LineFragment2.default(lineBox, line);
    });

    lineFragments.forEach(function (lineFragment, i) {
      finalizeLineFragment(engines)(lineFragment, style, i === lineFragments.length - 1);
    });

    return new _Block2.default(lineFragments);
  };
};

var typesetter = function typesetter(engines) {
  return function (containers) {
    return function (glyphStrings) {
      var paragraphs = [].concat(glyphStrings);

      var layoutContainer = function layoutContainer(rect, container) {
        var paragraphRect = rect.copy();
        var nextParagraph = paragraphs.shift();

        while (nextParagraph) {
          var block = layoutParagraph(engines)(nextParagraph, container, paragraphRect);

          if (paragraphRect.height >= block.height) {
            container.blocks.push(block);
            paragraphRect = paragraphRect.copy();
            paragraphRect.y += block.height;
            paragraphRect.height -= block.height;
            nextParagraph = paragraphs.shift();
          } else {
            paragraphs.unshift(nextParagraph);
            break;
          }
        }
      };

      return containers.forEach(function (container) {
        layoutContainer(container.bbox.toRect(), container);
      });
    };
  };
};

exports.default = typesetter;