'use strict';

exports.__esModule = true;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _cubic2quad = require('cubic2quad');

var _cubic2quad2 = _interopRequireDefault(_cubic2quad);

var _BBox = require('./BBox');

var _BBox2 = _interopRequireDefault(_BBox);

var _Polygon = require('./Polygon');

var _Polygon2 = _interopRequireDefault(_Polygon);

var _Point = require('./Point');

var _Point2 = _interopRequireDefault(_Point);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SVG_COMMANDS = {
  moveTo: 'M',
  lineTo: 'L',
  quadraticCurveTo: 'Q',
  bezierCurveTo: 'C',
  closePath: 'Z'
};

// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.
var KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);

/**
 * Path objects are returned by glyphs and represent the actual
 * vector outlines for each glyph in the font. Paths can be converted
 * to SVG path data strings, or to functions that can be applied to
 * render the path to a graphics context.
 */

var Path = function () {
  function Path() {
    (0, _classCallCheck3.default)(this, Path);

    this.commands = [];
    this._bbox = null;
    this._cbox = null;
    this._bezier = false;
    this._quadratic = false;
  }

  Path.prototype.rect = function rect(x, y, width, height) {
    this.moveTo(x, y);
    this.lineTo(x + width, y);
    this.lineTo(x + width, y + height);
    this.lineTo(x, y + height);
    this.closePath();
    return this;
  };

  Path.prototype.ellipse = function ellipse(x, y, r1) {
    var r2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : r1;

    // based on http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas/2173084#2173084
    x -= r1;
    y -= r2;
    var ox = r1 * KAPPA;
    var oy = r2 * KAPPA;
    var xe = x + r1 * 2;
    var ye = y + r2 * 2;
    var xm = x + r1;
    var ym = y + r2;

    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    this.closePath();
    return this;
  };

  Path.prototype.circle = function circle(x, y, radius) {
    this.ellipse(x, y, radius);
  };

  Path.prototype.append = function append(path) {
    for (var _iterator = path.commands, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      var _ref = _ref2;
      var command = _ref.command,
          args = _ref.args;

      this[command].apply(this, args);
    }

    return this;
  };

  /**
   * Compiles the path to a JavaScript function that can be applied with
   * a graphics context in order to render the path.
   * @return {string}
   */


  Path.prototype.toFunction = function toFunction() {
    var cmds = this.commands.map(function (c) {
      return '  ctx.' + c.command + '(' + c.args.join(', ') + ');';
    });
    return new Function('ctx', cmds.join('\n'));
  };

  /**
   * Converts the path to an SVG path data string
   * @return {string}
   */


  Path.prototype.toSVG = function toSVG() {
    var cmds = this.commands.map(function (c) {
      var args = c.args.map(function (arg) {
        return Math.round(arg * 100) / 100;
      });
      return '' + SVG_COMMANDS[c.command] + args.join(' ');
    });

    return cmds.join('');
  };

  /**
   * Gets the 'control box' of a path.
   * This is like the bounding box, but it includes all points including
   * control points of bezier segments and is much faster to compute than
   * the real bounding box.
   * @type {BBox}
   */


  Path.prototype.mapPoints = function mapPoints(fn) {
    var path = new Path();

    for (var _iterator2 = this.commands, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref3;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref3 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref3 = _i2.value;
      }

      var c = _ref3;

      var args = [];
      for (var _i3 = 0; _i3 < c.args.length; _i3 += 2) {
        var _fn = fn(c.args[_i3], c.args[_i3 + 1]),
            x = _fn[0],
            y = _fn[1];

        args.push(x, y);
      }

      path[c.command].apply(path, args);
    }

    return path;
  };

  Path.prototype.transform = function transform(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints(function (x, y) {
      x = m0 * x + m2 * y + m4;
      y = m1 * x + m3 * y + m5;
      return [x, y];
    });
  };

  Path.prototype.translate = function translate(x, y) {
    return this.transform(1, 0, 0, 1, x, y);
  };

  Path.prototype.rotate = function rotate(angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  };

  Path.prototype.scale = function scale(scaleX) {
    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;

    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  };

  Path.prototype.quadraticToBezier = function quadraticToBezier() {
    if (!this._quadratic) {
      return this;
    }

    var path = new Path();
    var x = 0;
    var y = 0;

    for (var _iterator3 = this.commands, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref4;

      if (_isArray3) {
        if (_i4 >= _iterator3.length) break;
        _ref4 = _iterator3[_i4++];
      } else {
        _i4 = _iterator3.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var c = _ref4;

      if (c.command === 'quadraticCurveTo') {
        var quads = _quadraticToBezier.apply(undefined, [x, y].concat(c.args));

        for (var _i5 = 2; _i5 < quads.length; _i5 += 6) {
          path.bezierCurveTo(quads[_i5], quads[_i5 + 1], quads[_i5 + 2], quads[_i5 + 3], quads[_i5 + 4], quads[_i5 + 5]);
        }
      } else {
        path[c.command].apply(path, c.args);
        x = c.args[c.args.length - 2] || 0;
        y = c.args[c.args.length - 1] || 0;
      }
    }

    return path;
  };

  Path.prototype.bezierToQuadratic = function bezierToQuadratic() {
    if (!this._bezier) {
      return this;
    }

    var path = new Path();
    var x = 0;
    var y = 0;

    for (var _iterator4 = this.commands, _isArray4 = Array.isArray(_iterator4), _i6 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
      var _ref5;

      if (_isArray4) {
        if (_i6 >= _iterator4.length) break;
        _ref5 = _iterator4[_i6++];
      } else {
        _i6 = _iterator4.next();
        if (_i6.done) break;
        _ref5 = _i6.value;
      }

      var c = _ref5;

      if (c.command === 'bezierCurveTo') {
        var quads = _cubic2quad2.default.apply(undefined, [x, y].concat(c.args, [0.1]));

        for (var _i7 = 2; _i7 < quads.length; _i7 += 4) {
          path.quadraticCurveTo(quads[_i7], quads[_i7 + 1], quads[_i7 + 2], quads[_i7 + 3]);
        }
      } else {
        path[c.command].apply(path, c.args);
        x = c.args[c.args.length - 2] || 0;
        y = c.args[c.args.length - 1] || 0;
      }
    }

    return path;
  };

  Path.prototype.flatten = function flatten() {
    if (this.isFlat) {
      return this;
    }

    var res = new Path();
    var cx = 0;
    var cy = 0;
    var sx = 0;
    var sy = 0;

    for (var _iterator5 = this.commands, _isArray5 = Array.isArray(_iterator5), _i8 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
      var _ref7;

      if (_isArray5) {
        if (_i8 >= _iterator5.length) break;
        _ref7 = _iterator5[_i8++];
      } else {
        _i8 = _iterator5.next();
        if (_i8.done) break;
        _ref7 = _i8.value;
      }

      var _ref6 = _ref7;
      var command = _ref6.command,
          args = _ref6.args;

      switch (command) {
        case 'moveTo':
          res.moveTo.apply(res, args);
          cx = sx = args[0];
          cy = sy = args[1];
          break;

        case 'lineTo':
          res.lineTo.apply(res, args);
          cx = args[0];
          cy = args[1];
          break;

        case 'quadraticCurveTo':
          args = _quadraticToBezier.apply(undefined, [cx, cy].concat(args));
        // fall through!

        case 'bezierCurveTo':
          subdivideBezierWithFlatness.apply(undefined, [res, 0.6, cx, cy].concat(args));
          cx = args[4];
          cy = args[5];
          break;

        case 'closePath':
          cx = sx;
          cy = sy;
          res.closePath();
          break;

        default:
          throw new Error('Unknown path command: ' + command);
      }
    }

    return res;
  };

  Path.prototype.reverse = function reverse() {
    var res = new Path();
    var commands = this.commands;
    var start = commands[0];

    for (var _i9 = 1; _i9 < commands.length; _i9++) {
      var _commands$_i = commands[_i9],
          command = _commands$_i.command,
          args = _commands$_i.args;

      if (command !== 'moveTo' && _i9 + 1 < commands.length) {
        continue;
      }

      var closed = false;
      var j = _i9;

      if (command === 'moveTo') {
        j--;
      }

      var move = commands[j].command === 'closePath' ? start : commands[j];
      res.moveTo(move.args[0], move.args[1]);

      for (; commands[j].command !== 'moveTo'; j--) {
        var prev = commands[j - 1];
        var cur = commands[j];
        var px = prev.args[prev.args.length - 2];
        var py = prev.args[prev.args.length - 1];

        switch (cur.command) {
          case 'lineTo':
            if (closed && prev.command === 'moveTo') {
              res.closePath();
            } else {
              res.lineTo(px, py);
            }
            break;

          case 'bezierCurveTo':
            res.bezierCurveTo(cur.args[2], cur.args[3], cur.args[0], cur.args[1], px, py);
            if (closed && prev.command === 'moveTo') {
              prev.closePath();
            }
            break;

          case 'quadraticCurveTo':
            res.quadraticCurveTo(cur.args[0], cur.args[1], px, py);
            if (closed && prev.command === 'moveTo') {
              prev.closePath();
            }
            break;

          case 'closePath':
            closed = true;
            res.lineTo(px, py);
            break;

          default:
            throw new Error('Unknown path command: ' + command);
        }
      }

      start = commands[_i9];
    }

    return res;
  };

  Path.prototype.toPolygon = function toPolygon() {
    // Flatten and canonicalize the path.
    var path = this.flatten();
    if (!path.isClockwise) {
      path = path.reverse();
    }

    var contour = [];
    var polygon = new _Polygon2.default();

    for (var _iterator6 = path.commands, _isArray6 = Array.isArray(_iterator6), _i10 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
      var _ref9;

      if (_isArray6) {
        if (_i10 >= _iterator6.length) break;
        _ref9 = _iterator6[_i10++];
      } else {
        _i10 = _iterator6.next();
        if (_i10.done) break;
        _ref9 = _i10.value;
      }

      var _ref8 = _ref9;
      var command = _ref8.command,
          args = _ref8.args;

      switch (command) {
        case 'moveTo':
          if (contour.length) {
            polygon.addContour(contour);
            contour = [];
          }

          contour.push(new _Point2.default(args[0], args[1]));
          break;

        case 'lineTo':
          contour.push(new _Point2.default(args[0], args[1]));
          break;

        case 'closePath':
          if (contour.length) {
            polygon.addContour(contour);
            contour = [];
          }
          break;

        default:
          throw new Error('Unsupported path command: ' + command);
      }
    }

    return polygon;
  };

  (0, _createClass3.default)(Path, [{
    key: 'cbox',
    get: function get() {
      if (!this._cbox) {
        var cbox = new _BBox2.default();
        for (var _iterator7 = this.commands, _isArray7 = Array.isArray(_iterator7), _i11 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
          var _ref10;

          if (_isArray7) {
            if (_i11 >= _iterator7.length) break;
            _ref10 = _iterator7[_i11++];
          } else {
            _i11 = _iterator7.next();
            if (_i11.done) break;
            _ref10 = _i11.value;
          }

          var command = _ref10;

          for (var _i12 = 0; _i12 < command.args.length; _i12 += 2) {
            cbox.addPoint(command.args[_i12], command.args[_i12 + 1]);
          }
        }

        this._cbox = (0, _freeze2.default)(cbox);
      }

      return this._cbox;
    }

    /**
     * Gets the exact bounding box of the path by evaluating curve segments.
     * Slower to compute than the control box, but more accurate.
     * @type {BBox}
     */

  }, {
    key: 'bbox',
    get: function get() {
      if (this._bbox) {
        return this._bbox;
      }

      var bbox = new _BBox2.default();
      var cx = 0;
      var cy = 0;

      var f = function f(t) {
        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
      };

      for (var _iterator8 = this.commands, _isArray8 = Array.isArray(_iterator8), _i13 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {
        var _ref12;

        if (_isArray8) {
          if (_i13 >= _iterator8.length) break;
          _ref12 = _iterator8[_i13++];
        } else {
          _i13 = _iterator8.next();
          if (_i13.done) break;
          _ref12 = _i13.value;
        }

        var _ref11 = _ref12;
        var command = _ref11.command,
            args = _ref11.args;

        switch (command) {
          case 'moveTo':
          case 'lineTo':
            var _args = args,
                x = _args[0],
                y = _args[1];

            bbox.addPoint(x, y);
            cx = x;
            cy = y;
            break;

          case 'quadraticCurveTo':
            args = _quadraticToBezier.apply(undefined, [cx, cy].concat(args));
          // fall through

          case 'bezierCurveTo':
            var _args2 = args,
                cp1x = _args2[0],
                cp1y = _args2[1],
                cp2x = _args2[2],
                cp2y = _args2[3],
                p3x = _args2[4],
                p3y = _args2[5];

            // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html

            bbox.addPoint(p3x, p3y);

            var _p = [cx, cy];
            var _p2 = [cp1x, cp1y];
            var _p3 = [cp2x, cp2y];
            var _p4 = [p3x, p3y];

            for (var _i14 = 0; _i14 <= 1; _i14++) {
              var b = 6 * _p[_i14] - 12 * _p2[_i14] + 6 * _p3[_i14];
              var a = -3 * _p[_i14] + 9 * _p2[_i14] - 9 * _p3[_i14] + 3 * _p4[_i14];
              var c = 3 * _p2[_i14] - 3 * _p[_i14];

              if (a === 0) {
                if (b === 0) {
                  continue;
                }

                var t = -c / b;
                if (0 < t && t < 1) {
                  if (_i14 === 0) {
                    bbox.addPoint(f(t), bbox.maxY);
                  } else if (_i14 === 1) {
                    bbox.addPoint(bbox.maxX, f(t));
                  }
                }

                continue;
              }

              var b2ac = Math.pow(b, 2) - 4 * c * a;
              if (b2ac < 0) {
                continue;
              }

              var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
              if (0 < t1 && t1 < 1) {
                if (_i14 === 0) {
                  bbox.addPoint(f(t1), bbox.maxY);
                } else if (_i14 === 1) {
                  bbox.addPoint(bbox.maxX, f(t1));
                }
              }

              var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
              if (0 < t2 && t2 < 1) {
                if (_i14 === 0) {
                  bbox.addPoint(f(t2), bbox.maxY);
                } else if (_i14 === 1) {
                  bbox.addPoint(bbox.maxX, f(t2));
                }
              }
            }

            cx = p3x;
            cy = p3y;
            break;
          default:
            break;
        }
      }

      return this._bbox = (0, _freeze2.default)(bbox);
    }
  }, {
    key: 'isFlat',
    get: function get() {
      return !this._bezier && !this._quadratic;
    }
  }, {
    key: 'isClockwise',
    get: function get() {
      // Source: http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order
      // Original solution define that f the sum is positive, the points are in clockwise order.
      // We check for the opposite condition because we are in an inverted cartesian coordinate system
      var sx = 0;
      var sy = 0;
      var cx = 0;
      var cy = 0;
      var sum = 0;

      var path = this.flatten();

      for (var _iterator9 = path.commands, _isArray9 = Array.isArray(_iterator9), _i15 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {
        var _ref14;

        if (_isArray9) {
          if (_i15 >= _iterator9.length) break;
          _ref14 = _iterator9[_i15++];
        } else {
          _i15 = _iterator9.next();
          if (_i15.done) break;
          _ref14 = _i15.value;
        }

        var _ref13 = _ref14;
        var command = _ref13.command,
            args = _ref13.args;
        var x = args[0],
            y = args[1];

        switch (command) {
          case 'moveTo':
            cx = x;
            cy = y;
            sx = x;
            sy = y;
            break;

          case 'lineTo':
            sum += (x - cx) * (cy + y);

            cx = x;
            cy = y;
            break;

          case 'closePath':
            sum += (sx - cx) * (sy + cy);
            break;

          default:
            throw new Error('Unknown path command: ' + command);
        }
      }

      return sum < 0;
    }
  }]);
  return Path;
}();

var _loop = function _loop(command) {
  Path.prototype[command] = function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._bbox = this._cbox = null;
    this.commands.push({
      command: command,
      args: args
    });

    if (command === 'bezierCurveTo') {
      this._bezier = true;
    } else if (command === 'quadraticCurveTo') {
      this._quadratic = true;
    }

    return this;
  };
};

for (var _iterator10 = (0, _keys2.default)(SVG_COMMANDS), _isArray10 = Array.isArray(_iterator10), _i16 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {
  var _ref15;

  if (_isArray10) {
    if (_i16 >= _iterator10.length) break;
    _ref15 = _iterator10[_i16++];
  } else {
    _i16 = _iterator10.next();
    if (_i16.done) break;
    _ref15 = _i16.value;
  }

  var command = _ref15;

  _loop(command);
}

function _quadraticToBezier(cx, cy, qp1x, qp1y, x, y) {
  // http://fontforge.org/bezier.html
  var cp1x = cx + 2 / 3 * (qp1x - cx); // CP1 = QP0 + 2/3 * (QP1-QP0)
  var cp1y = cy + 2 / 3 * (qp1y - cy);
  var cp2x = x + 2 / 3 * (qp1x - x); // CP2 = QP2 + 2/3 * (QP1-QP2)
  var cp2y = y + 2 / 3 * (qp1y - y);
  return [cp1x, cp1y, cp2x, cp2y, x, y];
}

function subdivideBezierWithFlatness(path, flatness, cx, cy, cp1x, cp1y, cp2x, cp2y, x, y) {
  var dx1 = cp1x - cx;
  var dx2 = cp2x - cp1x;
  var dx3 = x - cp2x;
  var dx4 = dx2 - dx1;
  var dx5 = dx3 - dx2;
  var dx6 = dx5 - dx4;

  var dy1 = cp1y - cy;
  var dy2 = cp2y - cp1y;
  var dy3 = y - cp2y;
  var dy4 = dy2 - dy1;
  var dy5 = dy3 - dy2;
  var dy6 = dy5 - dy4;

  var d1 = dx4 * dx4 + dy4 * dy4;
  var d2 = dx5 * dx5 + dy5 * dy5;
  var flatnessSqr = flatness * flatness;
  var wat = 9 * Math.max(d1, d2) / 16;

  var wat2 = 6 * dx6;
  var wat3 = 6 * (dx4 + dx6);
  var wat4 = 3 * (dx1 + dx4) + dx6;

  var wat5 = 6 * dy6;
  var wat6 = 6 * (dy4 + dy6);
  var wat7 = 3 * (dy1 + dy4) + dy6;

  var f = 1;

  while (wat > flatnessSqr && f <= 65535) {
    wat2 /= 8;
    wat3 = wat3 / 4 - wat2;
    wat4 = wat4 / 2 - wat3 / 2;

    wat5 /= 8;
    wat6 = wat6 / 4 - wat5;
    wat7 = wat7 / 2 - wat6 / 2;

    wat /= 16;
    f <<= 1;
  }

  while (--f > 0) {
    cx += wat4;
    wat4 += wat3;
    wat3 += wat2;

    cy += wat7;
    wat7 += wat6;
    wat6 += wat5;

    path.lineTo(cx, cy);
  }

  path.lineTo(x, y);
}

exports.default = Path;