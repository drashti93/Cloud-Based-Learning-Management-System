'use strict';

exports.__esModule = true;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _iterator6 = require('babel-runtime/core-js/symbol/iterator');

var _iterator7 = _interopRequireDefault(_iterator6);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _unicodeProperties = require('@react-pdf/unicode-properties');

var _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/css-text-3/#hanging-punctuation
var HANGING_PUNCTUATION_START_CATEGORIES = new _set2.default(['Ps', 'Pi', 'Pf']);
var HANGING_PUNCTUATION_END_CATEGORIES = new _set2.default(['Pe', 'Pi', 'Pf']);
var HANGING_PUNCTUATION_END_CODEPOINTS = new _set2.default([0x002c, // COMMA
0x002e, // FULL STOP
0x060c, // ARABIC COMMA
0x06d4, // ARABIC FULL STOP
0x3001, // IDEOGRAPHIC COMMA
0x3002, // IDEOGRAPHIC FULL STOP
0xff0c, // FULLWIDTH COMMA
0xff0e, // FULLWIDTH FULL STOP
0xfe50, // SMALL COMMA
0xfe51, // SMALL IDEOGRAPHIC COMMA
0xfe52, // SMALL FULL STOP
0xff61, // HALFWIDTH IDEOGRAPHIC FULL STOP
0xff64, // HALFWIDTH IDEOGRAPHIC COMMA
0x002d // HYPHEN
]);

var _runIndexAtGlyphIndex = function _runIndexAtGlyphIndex(glyphRuns, index) {
  var count = 0;

  for (var i = 0; i < glyphRuns.length; i++) {
    var run = glyphRuns[i];

    if (count <= index && index < count + run.glyphs.length) {
      return i;
    }

    count += run.glyphs.length;
  }

  return glyphRuns.length - 1;
};

var sliceRuns = function sliceRuns(glyphRuns, start, end) {
  if (glyphRuns.length === 0) return [];

  var startRunIndex = _runIndexAtGlyphIndex(glyphRuns, start);
  var endRunIndex = _runIndexAtGlyphIndex(glyphRuns, end);
  var startRun = glyphRuns[startRunIndex];
  var endRun = glyphRuns[endRunIndex];
  var runs = [];

  runs.push(startRun.slice(start - startRun.start, end - startRun.start));

  if (endRunIndex !== startRunIndex) {
    runs.push.apply(runs, glyphRuns.slice(startRunIndex + 1, endRunIndex));

    if (end - endRun.start !== 0) {
      runs.push(endRun.slice(0, end - endRun.start));
    }
  }

  for (var _iterator = runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var run = _ref;

    run.start -= start;
    run.end -= start;
    run.stringIndices = run.stringIndices.map(function (s) {
      return s - start;
    });
  }

  return runs;
};

var normalizeStringIndices = function normalizeStringIndices(glyphRuns) {
  glyphRuns.forEach(function (run) {
    run.stringIndices = run.stringIndices.map(function (index) {
      return index - run.stringIndices[0];
    });
  });
  return glyphRuns;
};

var GlyphString = function () {
  function GlyphString(string) {
    var glyphRuns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    (0, _classCallCheck3.default)(this, GlyphString);

    this.string = string;
    this.glyphRuns = normalizeStringIndices(glyphRuns);
  }

  GlyphString.prototype.slice = function slice(start, end) {
    var stringStart = this.stringIndexForGlyphIndex(start);
    var stringEnd = this.stringIndexForGlyphIndex(end);
    var glyphRuns = sliceRuns(this.glyphRuns, start, end);

    var result = new GlyphString(this.string.slice(stringStart, stringEnd), glyphRuns);

    // Ligature splitting. If happens to slice in a ligature, we split create
    var previousGlyph = this.glyphAtIndex(start - 1);
    var lastGlyph = this.glyphAtIndex(end - 1);

    if (lastGlyph && lastGlyph.isLigature) {
      result.deleteGlyph(result.length - 1);
      result.insertGlyph(result.length, lastGlyph.codePoints[0]);
    }

    // Add the ligature remaining chars to result
    if (previousGlyph && previousGlyph.isLigature) {
      for (var i = 1; i < previousGlyph.codePoints.length; i++) {
        result.insertGlyph(i - 1, previousGlyph.codePoints[i]);
      }
    }

    return result;
  };

  GlyphString.prototype.runIndexAtGlyphIndex = function runIndexAtGlyphIndex(index) {
    return _runIndexAtGlyphIndex(this.glyphRuns, index);
  };

  GlyphString.prototype.runAtGlyphIndex = function runAtGlyphIndex(index) {
    for (var i = 0; i < this.glyphRuns.length; i++) {
      var run = this.glyphRuns[i];

      if (run.start <= index && run.end > index) {
        return run;
      }
    }

    return this.glyphRuns[this.glyphRuns.length - 1];
  };

  GlyphString.prototype.runIndexAtStringIndex = function runIndexAtStringIndex(index) {
    var offset = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      var run = this.glyphRuns[i];

      if (offset + run.stringStart <= index && offset + run.stringEnd >= index) {
        return i;
      }

      offset += run.stringEnd;
    }

    return this.glyphRuns.length - 1;
  };

  GlyphString.prototype.runAtStringIndex = function runAtStringIndex(index) {
    return this.glyphRuns[this.runIndexAtStringIndex(index)];
  };

  GlyphString.prototype.glyphAtIndex = function glyphAtIndex(index) {
    var run = this.runAtGlyphIndex(index);
    return run.glyphs[this.start + index - run.start];
  };

  GlyphString.prototype.positionAtIndex = function positionAtIndex(index) {
    var run = void 0;
    var count = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      run = this.glyphRuns[i];

      if (count <= index && index < count + run.positions.length) {
        return run.positions[index - count];
      }

      count += run.positions.length;
    }

    return run.positions[run.positions.length - 1];
  };

  GlyphString.prototype.getGlyphWidth = function getGlyphWidth(index) {
    return this.positionAtIndex(index).xAdvance;
  };

  GlyphString.prototype.glyphIndexAtOffset = function glyphIndexAtOffset(width) {
    var offset = 0;
    var index = 0;

    for (var _iterator2 = this.glyphRuns, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var run = _ref2;

      if (offset + run.advanceWidth > width) {
        for (var _iterator3 = run.positions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
          var _ref3;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
          }

          var position = _ref3;

          var w = position.xAdvance;
          if (offset + w > width) {
            return index;
          }

          offset += w;
          index++;
        }
      } else {
        offset += run.advanceWidth;
        index += run.glyphs.length;
      }
    }

    return index;
  };

  GlyphString.prototype.stringIndexForGlyphIndex = function stringIndexForGlyphIndex(index) {
    var count = 0;
    var offset = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      var run = this.glyphRuns[i];

      if (offset <= index && offset + run.length > index) {
        return count + run.stringIndices[index - run.start];
      }

      offset += run.length;
      count += run.glyphIndices.length;
    }

    return count;
  };

  GlyphString.prototype.glyphIndexForStringIndex = function glyphIndexForStringIndex(index) {
    var run = void 0;
    var count = 0;
    var offset = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      run = this.glyphRuns[i];

      if (offset <= index && index < offset + run.stringEnd + 1) {
        return count + run.glyphIndices[index - offset];
      }

      count += run.glyphs.length;
      offset += run.stringEnd + 1;
    }

    return offset;
  };

  GlyphString.prototype.codePointAtGlyphIndex = function codePointAtGlyphIndex(glyphIndex) {
    return this.string.codePointAt(this.stringIndexForGlyphIndex(glyphIndex));
  };

  GlyphString.prototype.charAtGlyphIndex = function charAtGlyphIndex(glyphIndex) {
    return this.string.charAt(this.stringIndexForGlyphIndex(glyphIndex));
  };

  GlyphString.prototype.offsetAtGlyphIndex = function offsetAtGlyphIndex(glyphIndex) {
    var offset = 0;
    var count = glyphIndex;

    for (var _iterator4 = this.glyphRuns, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var run = _ref4;

      for (var i = 0; i < run.glyphs.length; i++) {
        if (count === 0) {
          return offset;
        }

        offset += run.positions[i].xAdvance;
        count -= 1;
      }
    }

    return offset;
  };

  GlyphString.prototype.indexOf = function indexOf(string) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var stringIndex = this.stringIndexForGlyphIndex(index);
    var nextIndex = this.string.indexOf(string, stringIndex);

    if (nextIndex === -1) return -1;

    return this.glyphIndexForStringIndex(nextIndex);
  };

  GlyphString.prototype.getUnicodeCategory = function getUnicodeCategory(index) {
    var codePoint = this.codePointAtGlyphIndex(index);
    return codePoint ? _unicodeProperties2.default.getCategory(codePoint) : null;
  };

  GlyphString.prototype.isWhiteSpace = function isWhiteSpace(index) {
    var codePoint = this.codePointAtGlyphIndex(index);
    return codePoint ? _unicodeProperties2.default.isWhiteSpace(codePoint) : false;
  };

  GlyphString.prototype.isHangingPunctuationStart = function isHangingPunctuationStart(index) {
    return HANGING_PUNCTUATION_START_CATEGORIES.has(this.getUnicodeCategory(index));
  };

  GlyphString.prototype.isHangingPunctuationEnd = function isHangingPunctuationEnd(index) {
    return HANGING_PUNCTUATION_END_CATEGORIES.has(this.getUnicodeCategory(index)) || HANGING_PUNCTUATION_END_CODEPOINTS.has(this.codePointAtGlyphIndex(index));
  };

  GlyphString.prototype.insertGlyph = function insertGlyph(index, codePoint) {
    var runIndex = this.runIndexAtGlyphIndex(index);
    var run = this.glyphRuns[runIndex];
    var _run$attributes = run.attributes,
        font = _run$attributes.font,
        fontSize = _run$attributes.fontSize;

    var glyph = run.attributes.font.glyphForCodePoint(codePoint);
    var scale = fontSize / font.unitsPerEm;
    var glyphIndex = this.start + index - run.start;

    if (this._end) this._end += 1;

    run.glyphs.splice(glyphIndex, 0, glyph);
    run.stringIndices.splice(glyphIndex, 0, run.stringIndices[glyphIndex]);

    for (var i = 0; i < run.glyphIndices.length; i++) {
      if (run.glyphIndices[i] >= glyphIndex) {
        run.glyphIndices[i] += 1;
      }
    }

    run.positions.splice(glyphIndex, 0, {
      xAdvance: glyph.advanceWidth * scale,
      yAdvance: 0,
      xOffset: 0,
      yOffset: run.attributes.yOffset * font.unitsPerEm
    });

    run.end += 1;

    for (var _i5 = runIndex + 1; _i5 < this.glyphRuns.length; _i5++) {
      this.glyphRuns[_i5].start += 1;
      this.glyphRuns[_i5].end += 1;
    }

    this.glyphRunsCache = null;
  };

  GlyphString.prototype.deleteGlyph = function deleteGlyph(index) {
    if (index < 0 || index >= this.length) return;

    var runIndex = this.runIndexAtGlyphIndex(index);
    var run = this.glyphRuns[runIndex];
    var glyphIndex = this.start + index - run.start;

    if (this._end) this._end -= 1;

    run.glyphs.splice(glyphIndex, 1);
    run.positions.splice(glyphIndex, 1);
    run.stringIndices.splice(glyphIndex, 1);

    for (var i = 0; i < run.glyphIndices.length; i++) {
      if (run.glyphIndices[i] >= glyphIndex) {
        run.glyphIndices[i] -= 1;
      }
    }

    run.end--;

    for (var _i6 = runIndex + 1; _i6 < this.glyphRuns.length; _i6++) {
      this.glyphRuns[_i6].start--;
      this.glyphRuns[_i6].end--;
    }

    this.glyphRunsCache = null;
  };

  GlyphString.prototype.copy = function copy() {
    return new GlyphString(this.string, this.glyphRuns.map(function (run) {
      return run.copy();
    }));
  };

  GlyphString.prototype[_iterator7.default] = /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    var x, _iterator5, _isArray5, _i7, _ref5, run, i;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            x = 0;
            _iterator5 = this.glyphRuns, _isArray5 = Array.isArray(_iterator5), _i7 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);

          case 2:
            if (!_isArray5) {
              _context.next = 8;
              break;
            }

            if (!(_i7 >= _iterator5.length)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt('break', 23);

          case 5:
            _ref5 = _iterator5[_i7++];
            _context.next = 12;
            break;

          case 8:
            _i7 = _iterator5.next();

            if (!_i7.done) {
              _context.next = 11;
              break;
            }

            return _context.abrupt('break', 23);

          case 11:
            _ref5 = _i7.value;

          case 12:
            run = _ref5;
            i = 0;

          case 14:
            if (!(i < run.glyphs.length)) {
              _context.next = 21;
              break;
            }

            _context.next = 17;
            return {
              glyph: run.glyphs[i],
              position: run.positions[i],
              run: run,
              x: x,
              index: run.start + i
            };

          case 17:

            x += run.positions[i].xAdvance;

          case 18:
            i++;
            _context.next = 14;
            break;

          case 21:
            _context.next = 2;
            break;

          case 23:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  });
  (0, _createClass3.default)(GlyphString, [{
    key: 'start',
    get: function get() {
      if (this.glyphRuns.length === 0) return 0;
      return this.glyphRuns[0].start;
    }
  }, {
    key: 'end',
    get: function get() {
      if (this.glyphRuns.length === 0) return 0;
      return this.glyphRuns[this.glyphRuns.length - 1].end;
    }
  }, {
    key: 'length',
    get: function get() {
      return this.end - this.start;
    }
  }, {
    key: 'advanceWidth',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return acc + run.advanceWidth;
      }, 0);
    }
  }, {
    key: 'height',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.max(acc, run.height);
      }, 0);
    }
  }, {
    key: 'ascent',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.max(acc, run.ascent);
      }, 0);
    }
  }, {
    key: 'descent',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.min(acc, run.descent);
      }, 0);
    }
  }]);
  return GlyphString;
}();

exports.default = GlyphString;