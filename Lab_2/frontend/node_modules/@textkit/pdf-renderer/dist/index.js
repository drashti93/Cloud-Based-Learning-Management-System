'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A TextRenderer renders text layout objects to a graphics context.
 */
exports.default = function (_ref) {
  var Rect = _ref.Rect;
  return function () {
    function PDFRenderer(ctx) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck3.default)(this, PDFRenderer);

      this.ctx = ctx;
      this.outlineBlocks = options.outlineBlocks || false;
      this.outlineLines = options.outlineLines || false;
      this.outlineRuns = options.outlineRuns || false;
      this.outlineAttachments = options.outlineAttachments || false;
    }

    PDFRenderer.prototype.render = function render(container) {
      for (var _iterator = container.blocks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref2;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref2 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref2 = _i.value;
        }

        var block = _ref2;

        this.renderBlock(block);
      }
    };

    PDFRenderer.prototype.renderBlock = function renderBlock(block) {
      if (this.outlineBlocks) {
        var _block$bbox = block.bbox,
            minX = _block$bbox.minX,
            minY = _block$bbox.minY,
            width = _block$bbox.width,
            height = _block$bbox.height;

        this.ctx.rect(minX, minY, width, height).stroke();
      }

      for (var _iterator2 = block.lines, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref3;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref3 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref3 = _i2.value;
        }

        var line = _ref3;

        this.renderLine(line);
      }
    };

    PDFRenderer.prototype.renderLine = function renderLine(line) {
      if (this.outlineLines) {
        this.ctx.rect(line.rect.x, line.rect.y, line.rect.width, line.rect.height).stroke();
      }

      this.ctx.save();
      this.ctx.translate(line.rect.x, line.rect.y + line.ascent);

      for (var _iterator3 = line.glyphRuns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref4;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref4 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref4 = _i3.value;
        }

        var run = _ref4;

        if (run.attributes.backgroundColor) {
          var backgroundRect = new Rect(0, -line.ascent, run.advanceWidth, line.rect.height);
          this.renderBackground(backgroundRect, run.attributes.backgroundColor);
        }

        this.renderRun(run);
      }

      this.ctx.restore();
      this.ctx.save();
      this.ctx.translate(line.rect.x, line.rect.y);

      for (var _iterator4 = line.decorationLines, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
        var _ref5;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref5 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref5 = _i4.value;
        }

        var decorationLine = _ref5;

        this.renderDecorationLine(decorationLine);
      }

      this.ctx.restore();
    };

    PDFRenderer.prototype.renderRun = function renderRun(run) {
      var _run$attributes = run.attributes,
          font = _run$attributes.font,
          fontSize = _run$attributes.fontSize,
          color = _run$attributes.color,
          link = _run$attributes.link,
          opacity = _run$attributes.opacity;


      if (this.outlineRuns) {
        this.ctx.rect(0, 0, run.advanceWidth, run.height).stroke();
      }

      this.ctx.fillColor(color);
      this.ctx.fillOpacity(opacity);

      if (link) {
        this.ctx.link(0, -run.height - run.descent, run.advanceWidth, run.height, link);
      }

      this.renderAttachments(run);

      if (font.sbix || font.COLR && font.CPAL) {
        this.ctx.save();
        this.ctx.translate(0, -run.ascent);

        for (var i = 0; i < run.glyphs.length; i++) {
          var position = run.positions[i];
          var glyph = run.glyphs[i];

          this.ctx.save();
          this.ctx.translate(position.xOffset, position.yOffset);

          glyph.render(this.ctx, fontSize);

          this.ctx.restore();
          this.ctx.translate(position.xAdvance, position.yAdvance);
        }

        this.ctx.restore();
      } else {
        this.ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);
        this.ctx._addGlyphs(run.glyphs, run.positions, 0, 0);
      }

      this.ctx.translate(run.advanceWidth, 0);
    };

    PDFRenderer.prototype.renderBackground = function renderBackground(rect, backgroundColor) {
      this.ctx.rect(rect.x, rect.y, rect.width, rect.height);
      this.ctx.fill(backgroundColor);
    };

    PDFRenderer.prototype.renderAttachments = function renderAttachments(run) {
      this.ctx.save();

      var font = run.attributes.font;

      var space = font.glyphForCodePoint(0x20);
      var objectReplacement = font.glyphForCodePoint(0xfffc);

      for (var i = 0; i < run.glyphs.length; i++) {
        var position = run.positions[i];
        var glyph = run.glyphs[i];

        this.ctx.translate(position.xAdvance, position.yOffset);

        if (glyph.id === objectReplacement.id && run.attributes.attachment) {
          this.renderAttachment(run.attributes.attachment);
          run.glyphs[i] = space;
        }
      }

      this.ctx.restore();
    };

    PDFRenderer.prototype.renderAttachment = function renderAttachment(attachment) {
      var _attachment$xOffset = attachment.xOffset,
          xOffset = _attachment$xOffset === undefined ? 0 : _attachment$xOffset,
          _attachment$yOffset = attachment.yOffset,
          yOffset = _attachment$yOffset === undefined ? 0 : _attachment$yOffset;


      this.ctx.translate(-attachment.width + xOffset, -attachment.height + yOffset);

      if (this.outlineAttachments) {
        this.ctx.rect(0, 0, attachment.width, attachment.height).stroke();
      }

      if (typeof attachment.render === 'function') {
        this.ctx.rect(0, 0, attachment.width, attachment.height);
        this.ctx.clip();
        attachment.render(this.ctx);
      } else if (attachment.image) {
        this.ctx.image(attachment.image, 0, 0, {
          fit: [attachment.width, attachment.height],
          align: 'center',
          valign: 'bottom'
        });
      }
    };

    PDFRenderer.prototype.renderDecorationLine = function renderDecorationLine(line) {
      this.ctx.lineWidth(line.rect.height);

      if (/dashed/.test(line.style)) {
        this.ctx.dash(3 * line.rect.height);
      } else if (/dotted/.test(line.style)) {
        this.ctx.dash(line.rect.height);
      }

      if (/wavy/.test(line.style)) {
        var dist = Math.max(2, line.rect.height);
        var step = 1.1 * dist;
        var stepCount = Math.floor(line.rect.width / (2 * step));

        // Adjust step to fill entire width
        var remainingWidth = line.rect.width - stepCount * 2 * step;
        var adjustment = remainingWidth / stepCount / 2;
        step += adjustment;

        var cp1y = line.rect.y + dist;
        var cp2y = line.rect.y - dist;
        var x = line.rect.x;


        this.ctx.moveTo(line.rect.x, line.rect.y);

        for (var i = 0; i < stepCount; i++) {
          this.ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);
          x += 2 * step;
        }
      } else {
        this.ctx.moveTo(line.rect.x, line.rect.y);
        this.ctx.lineTo(line.rect.maxX, line.rect.y);

        if (/double/.test(line.style)) {
          this.ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);
          this.ctx.lineTo(line.rect.maxX, line.rect.y + line.rect.height * 2);
        }
      }

      this.ctx.stroke(line.color);
    };

    return PDFRenderer;
  }();
};