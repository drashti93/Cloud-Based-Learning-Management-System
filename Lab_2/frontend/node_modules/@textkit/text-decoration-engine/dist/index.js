'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A TextDecorationEngine is used by a Typesetter to generate
 * DecorationLines for a line fragment, including underlines
 * and strikes.
 */

exports.default = function () {
  return function (_ref) {
    var Rect = _ref.Rect,
        Range = _ref.Range,
        DecorationLine = _ref.DecorationLine;

    // The base font size used for calculating underline thickness.
    var BASE_FONT_SIZE = 16;

    return function () {
      function TextDecorationEngine() {
        (0, _classCallCheck3.default)(this, TextDecorationEngine);
      }

      TextDecorationEngine.prototype.createDecorationLines = function createDecorationLines(lineFragment) {
        // Create initial underline and strikethrough lines
        var x = lineFragment.overflowLeft;
        var maxX = lineFragment.advanceWidth - lineFragment.overflowRight;
        var underlines = [];

        for (var _iterator = lineFragment.glyphRuns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var run = _ref2;

          var width = Math.min(maxX - x, run.advanceWidth);
          var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));

          if (run.attributes.underline) {
            var rect = new Rect(x, lineFragment.ascent, width, thickness);
            var _line = new DecorationLine(rect, run.attributes.underlineColor, run.attributes.underlineStyle);
            this.addDecorationLine(_line, underlines);
          }

          if (run.attributes.strike) {
            var y = lineFragment.ascent - run.ascent / 3;
            var _rect = new Rect(x, y, width, thickness);
            var _line2 = new DecorationLine(_rect, run.attributes.strikeColor, run.attributes.strikeStyle);
            this.addDecorationLine(_line2, lineFragment.decorationLines);
          }

          x += width;
        }

        // Adjust underline y positions, and intersect with glyph descenders.
        for (var _iterator2 = underlines, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _lineFragment$decorat;

          var _ref3;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref3 = _i2.value;
          }

          var line = _ref3;

          line.rect.y += line.rect.height * 2;
          (_lineFragment$decorat = lineFragment.decorationLines).push.apply(_lineFragment$decorat, this.intersectWithGlyphs(line, lineFragment));
        }
      };

      TextDecorationEngine.prototype.addDecorationLine = function addDecorationLine(line, lines) {
        var last = lines[lines.length - 1];
        if (!last || !last.merge(line)) {
          lines.push(line);
        }
      };

      /**
       * Computes the intersections between an underline and the glyphs in
       * a line fragment. Returns an array of DecorationLines omitting the
       * intersections.
       */


      TextDecorationEngine.prototype.intersectWithGlyphs = function intersectWithGlyphs(line, lineFragment) {
        // Find intersection ranges between underline and glyphs
        var x = 0;
        var y = lineFragment.ascent;
        var ranges = [];

        for (var _iterator3 = lineFragment.glyphRuns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
          var _ref4;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref4 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref4 = _i3.value;
          }

          var run = _ref4;

          if (!run.attributes.underline) {
            x += run.advanceWidth;
            continue;
          }

          for (var i = 0; i < run.glyphs.length; i++) {
            var position = run.positions[i];

            if (x >= line.rect.x && x <= line.rect.maxX) {
              var gx = x + position.xOffset;
              var gy = y + position.yOffset;

              // Standard fonts may not have a path to intersect with
              if (run.glyphs[i].path) {
                var path = run.glyphs[i].path.scale(run.scale, -run.scale).translate(gx, gy);
                var range = this.findPathIntersections(path, line.rect);

                if (range) {
                  ranges.push(range);
                }
              }
            }

            x += position.xAdvance;
            y += position.yAdvance;
          }
        }

        if (ranges.length === 0) {
          // No intersections. Return the original line.
          return [line];
        }

        var merged = Range.merge(ranges);

        // Generate underline segments omitting the intersections,
        // but only if the space warrents an underline.
        var lines = [];
        x = line.rect.x;
        for (var _iterator4 = merged, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
          var _ref6;

          if (_isArray4) {
            if (_i4 >= _iterator4.length) break;
            _ref6 = _iterator4[_i4++];
          } else {
            _i4 = _iterator4.next();
            if (_i4.done) break;
            _ref6 = _i4.value;
          }

          var _ref5 = _ref6;
          var start = _ref5.start;
          var end = _ref5.end;

          if (start - x > line.rect.height) {
            lines.push(line.slice(x, start));
          }

          x = end;
        }

        if (line.rect.maxX - x > line.rect.height) {
          lines.push(line.slice(x, line.rect.maxX));
        }

        return lines;
      };

      /**
       * Finds the intersections between a glyph path and an underline rectangle.
       * It models each contour of the path a straight line, and returns a range
       * containing the leftmost and rightmost intersection points, if any.
       */


      TextDecorationEngine.prototype.findPathIntersections = function findPathIntersections(path, rect) {
        var sx = 0;
        var sy = 0;
        var cx = 0;
        var cy = 0;
        var px = 0;
        var py = 0;
        var range = new Range(Infinity, -Infinity);
        var y1 = rect.y;
        var y2 = rect.maxY;
        var dialation = Math.ceil(rect.height);

        for (var _iterator5 = path.commands, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
          var _ref8;

          if (_isArray5) {
            if (_i5 >= _iterator5.length) break;
            _ref8 = _iterator5[_i5++];
          } else {
            _i5 = _iterator5.next();
            if (_i5.done) break;
            _ref8 = _i5.value;
          }

          var _ref7 = _ref8;
          var command = _ref7.command;
          var args = _ref7.args;

          switch (command) {
            case 'moveTo':
              sx = cx = args[0];
              sy = cy = args[1];
              continue;

            case 'lineTo':
              px = args[0];
              py = args[1];
              break;

            case 'quadraticCurveTo':
              px = args[2];
              py = args[3];
              break;

            case 'bezierCurveTo':
              px = args[4];
              py = args[5];
              break;

            case 'closePath':
              px = sx;
              py = sy;
              break;

            default:
              break;
          }

          this.findIntersectionPoint(y1, cx, cy, px, py, range);
          this.findIntersectionPoint(y2, cx, cy, px, py, range);

          if (cy >= y1 && cy <= y2 || cy <= y1 && cy >= y2) {
            range.extend(cx);
          }

          cx = px;
          cy = py;
        }

        if (range.start < range.end) {
          range.start -= dialation;
          range.end += dialation;
          return range;
        }

        return null;
      };

      TextDecorationEngine.prototype.findIntersectionPoint = function findIntersectionPoint(y, x1, y1, x2, y2, range) {
        if (y1 < y && y2 > y || y1 > y && y2 < y) {
          var x = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
          range.extend(x);
        }
      };

      return TextDecorationEngine;
    }();
  };
};