'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _lodash = require('lodash.clone');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.merge');

var _lodash4 = _interopRequireDefault(_lodash3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KASHIDA_PRIORITY = 0;
var WHITESPACE_PRIORITY = 1;
var LETTER_PRIORITY = 2;
var NULL_PRIORITY = 3;

var EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};

var EXPAND_CHAR_FACTOR = {
  before: 0.14453125, // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};

var SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875, // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};

var SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};

/**
 * A JustificationEngine is used by a Typesetter to perform line fragment
 * justification. This implementation is based on a description of Apple's
 * justification algorithm from a PDF in the Apple Font Tools package.
 */

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$expandCharFactor = _ref.expandCharFactor,
      expandCharFactor = _ref$expandCharFactor === undefined ? {} : _ref$expandCharFactor,
      _ref$expandWhitespace = _ref.expandWhitespaceFactor,
      expandWhitespaceFactor = _ref$expandWhitespace === undefined ? {} : _ref$expandWhitespace,
      _ref$shrinkCharFactor = _ref.shrinkCharFactor,
      shrinkCharFactor = _ref$shrinkCharFactor === undefined ? {} : _ref$shrinkCharFactor,
      _ref$shrinkWhitespace = _ref.shrinkWhitespaceFactor,
      shrinkWhitespaceFactor = _ref$shrinkWhitespace === undefined ? {} : _ref$shrinkWhitespace;

  return function () {
    return function () {
      function JustificationEngine() {
        (0, _classCallCheck3.default)(this, JustificationEngine);

        this.expandCharFactor = (0, _lodash4.default)(EXPAND_CHAR_FACTOR, expandCharFactor);
        this.expandWhitespaceFactor = (0, _lodash4.default)(EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor);
        this.shrinkCharFactor = (0, _lodash4.default)(SHRINK_CHAR_FACTOR, shrinkCharFactor);
        this.shrinkWhitespaceFactor = (0, _lodash4.default)(SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);
      }

      JustificationEngine.prototype.justify = function justify(line) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var factor = options.factor || 1;
        if (factor < 0 || factor > 1) {
          throw new Error('Invalid justification factor: ' + factor);
        }

        var gap = line.rect.width - line.advanceWidth;
        if (gap === 0) {
          return;
        }

        var factors = [];
        var start = 0;
        for (var _iterator = line.glyphRuns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var run = _ref2;

          factors.push.apply(factors, this.factor(line, start, run.glyphs, gap > 0 ? 'GROW' : 'SHRINK'));
          start += run.glyphs.length;
        }

        factors[0].before = 0;
        factors[factors.length - 1].after = 0;

        var distances = this.assign(gap, factors);

        var index = 0;
        for (var _iterator2 = line.glyphRuns, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _ref3;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref3 = _i2.value;
          }

          var _run = _ref3;

          for (var _iterator3 = _run.positions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
            var _ref4;

            if (_isArray3) {
              if (_i3 >= _iterator3.length) break;
              _ref4 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done) break;
              _ref4 = _i3.value;
            }

            var position = _ref4;

            position.xAdvance += distances[index++];
          }
        }
      };

      JustificationEngine.prototype.factor = function factor(line, start, glyphs, direction) {
        var charFactor = void 0;
        var whitespaceFactor = void 0;

        if (direction === 'GROW') {
          charFactor = (0, _lodash2.default)(this.expandCharFactor);
          whitespaceFactor = (0, _lodash2.default)(this.expandWhitespaceFactor);
        } else {
          charFactor = (0, _lodash2.default)(this.shrinkCharFactor);
          whitespaceFactor = (0, _lodash2.default)(this.shrinkWhitespaceFactor);
        }

        var factors = [];
        for (var index = 0; index < glyphs.length; index++) {
          var factor = void 0;
          var glyph = glyphs[index];
          if (line.isWhiteSpace(start + index)) {
            factor = (0, _lodash2.default)(whitespaceFactor);

            if (index === glyphs.length - 1) {
              factor.before = 0;

              if (index > 0) {
                factors[index - 1].after = 0;
              }
            }
          } else if (glyph.isMark && index > 0) {
            factor = (0, _lodash2.default)(factors[index - 1]);
            factor.before = 0;
            factors[index - 1].after = 0;
          } else {
            factor = (0, _lodash2.default)(charFactor);
          }

          factors.push(factor);
        }

        return factors;
      };

      JustificationEngine.prototype.assign = function assign(gap, factors) {
        var total = 0;
        var priorities = [];
        var unconstrained = [];

        for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority++) {
          priorities[_priority] = unconstrained[_priority] = 0;
        }

        // sum the factors at each priority
        for (var j = 0; j < factors.length; j++) {
          var factor = factors[j];
          var sum = factor.before + factor.after;
          total += sum;
          priorities[factor.priority] += sum;
          if (factor.unconstrained) {
            unconstrained[factor.priority] += sum;
          }
        }

        // choose the priorities that need to be applied
        var highestPriority = -1;
        var highestPrioritySum = 0;
        var remainingGap = gap;
        var priority = void 0;
        for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority++) {
          var prioritySum = priorities[priority];
          if (prioritySum !== 0) {
            if (highestPriority === -1) {
              highestPriority = priority;
              highestPrioritySum = prioritySum;
            }

            // if this priority covers the remaining gap, we're done
            if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
              priorities[priority] = remainingGap / prioritySum;
              unconstrained[priority] = 0;
              remainingGap = 0;
              break;
            }

            // mark that we need to use 100% of the adjustment from
            // this priority, and subtract the space that it consumes
            priorities[priority] = 1;
            remainingGap -= prioritySum;

            // if this priority has unconstrained glyphs, let them consume the remaining space
            if (unconstrained[priority] !== 0) {
              unconstrained[priority] = remainingGap / unconstrained[priority];
              remainingGap = 0;
              break;
            }
          }
        }

        // zero out remaining priorities (if any)
        for (var p = priority + 1; p <= NULL_PRIORITY; p++) {
          priorities[p] = 0;
          unconstrained[p] = 0;
        }

        // if there is still space left over, assign it to the highest priority that we saw.
        // this violates their factors, but it only happens in extreme cases
        if (remainingGap > 0 && highestPriority > -1) {
          priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
        }

        // create and return an array of distances to add to each glyph's advance
        var distances = [];
        for (var index = 0; index < factors.length; index++) {
          // the distance to add to this glyph is the sum of the space to add
          // after this glyph, and the space to add before the next glyph
          var _factor = factors[index];
          var next = factors[index + 1];
          var dist = _factor.after * priorities[_factor.priority];

          if (next) {
            dist += next.before * priorities[next.priority];
          }

          // if this glyph is unconstrained, add the unconstrained distance as well
          if (_factor.unconstrained) {
            dist += _factor.after * unconstrained[_factor.priority];
            if (next) {
              dist += next.before * unconstrained[next.priority];
            }
          }

          distances.push(dist);
        }

        return distances;
      };

      JustificationEngine.prototype.postprocess = function postprocess() {
        // do nothing by default
        return false;
      };

      return JustificationEngine;
    }();
  };
};