{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _utils = _interopRequireDefault(require(\"./utils\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction pickTypes(e) {\n  return e.dataTransfer ? e.dataTransfer.types : [];\n}\n\nfunction filterProps(props) {\n  var forbidden = ['types', 'className', 'enabled', 'wrapperComponent'];\n  return Object.keys(props).reduce(function (p, c) {\n    if (!forbidden.includes(c)) {\n      p[c] = props[c];\n    }\n\n    return p;\n  }, {});\n}\n\nvar Droppable =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Droppable, _React$Component);\n\n  function Droppable(props) {\n    var _this;\n\n    _classCallCheck(this, Droppable);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Droppable).call(this, props));\n    _this.state = {\n      over: false\n    };\n    _this.droppable = _react.default.createRef();\n    return _this;\n  }\n\n  _createClass(Droppable, [{\n    key: \"render\",\n    value: function render() {\n      var Tag = 'div';\n      var props = Object.assign({}, this.props);\n\n      if (this.props.wrapperComponent) {\n        Tag = this.props.wrapperComponent.type;\n        props = Object.assign(props, this.props.wrapperComponent.props);\n      }\n\n      var classes = 'Droppable';\n      if (props.className) classes += \" \".concat(props.className);\n      if (this.state.over) classes += ' over';\n      return _react.default.createElement(Tag, _extends({\n        ref: this.droppable,\n        className: classes\n      }, filterProps(props), {\n        onDrop: this.onDrop.bind(this),\n        onDragOver: this.onDragOver.bind(this),\n        onDragEnter: this.onDragEnter.bind(this),\n        onDragLeave: this.onDragLeave.bind(this),\n        onDragExit: this.onDragLeave.bind(this)\n      }), props.children);\n    }\n  }, {\n    key: \"onDragOver\",\n    value: function onDragOver(e) {\n      e.preventDefault();\n      if (!this.allowed(pickTypes(e))) return;\n      if (typeof this.props.onDragOver === 'function') this.props.onDragOver(e);\n    }\n  }, {\n    key: \"onDragEnter\",\n    value: function onDragEnter(e) {\n      e.preventDefault();\n      if (this.state.over) return;\n      if (!this.allowed(pickTypes(e))) return;\n      if (typeof this.props.onDragEnter === 'function') this.props.onDragEnter(e);\n      this.setState({\n        over: true\n      });\n    }\n  }, {\n    key: \"onDragLeave\",\n    value: function onDragLeave(e) {\n      e.preventDefault();\n      if (!this.allowed(pickTypes(e))) return;\n      var over = true;\n      if (e.clientX <= this.position.left || e.clientX >= this.position.right) over = false;\n      if (e.clientY <= this.position.top || e.clientY >= this.position.bottom) over = false;\n      if (over) return;\n      this.setState({\n        over: false\n      });\n      if (typeof this.props.onDragLeave === 'function') this.props.onDragLeave(e);\n    }\n  }, {\n    key: \"onDrop\",\n    value: function onDrop(e) {\n      e.preventDefault();\n      if (!this.allowed(pickTypes(e))) return;\n      this.setState({\n        over: false\n      });\n      var props = Object.assign({}, this.props);\n      if (this.props.wrapperComponent) props = Object.assign(props, this.props.wrapperComponent.props);\n      var data = !props.types ? null : [].concat(props.types).reduce(function (d, type) {\n        d[type] = e.dataTransfer.getData(type);\n        return d;\n      }, {});\n      if (typeof this.props.onDrop === 'function') this.props.onDrop(data, e);\n    }\n  }, {\n    key: \"allowed\",\n    value: function allowed(attemptingTypes) {\n      var props = Object.assign({}, this.props);\n      if (this.props.wrapperComponent) props = Object.assign(props, this.props.wrapperComponent.props);\n      if (!props.enabled) return false;\n\n      var _attemptingTypes = _utils.default.toArray(attemptingTypes);\n\n      if (!props.types) return true;\n      return [].concat(props.types).reduce(function (sum, type) {\n        if (_attemptingTypes.indexOf(type) >= 0) return true;\n        return sum;\n      }, false);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // TODO: Listen for window resize?\n      var node = this.droppable.current;\n      this.position = {\n        top: node.offsetTop + 5,\n        left: node.offsetLeft + 5,\n        right: node.offsetLeft + node.offsetWidth - 5,\n        bottom: node.offsetTop + node.offsetHeight - 5\n      };\n    }\n  }]);\n\n  return Droppable;\n}(_react.default.Component);\n\nexports.default = Droppable;\nDroppable.defaultProps = {\n  enabled: true\n};","map":null,"metadata":{},"sourceType":"script"}